package ocsf.server;// This file contains material supporting section 3.8 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com import java.net.*;import java.io.*;/*** The <code> osf.server.AbstractServer </code> class maintains a thread that waits* for connection attempts from clients. When a connection attempt occurs* it creates a new <code> osf.server.ConnectionToClient </code> instance which* runs as a thread. When a ocf.client is thus connected to the* osf.server, the two programs can then exchange <code> Object </code>* instances.<p>** Method <code> handleMessageFromClient </code> must be defined by* a concrete subclass. Several other hook methods may also be* overriden.<p>** Several public service methods are provided to applications that use* this framework, and several hook methods are also available<p>** Project Name: OCSF (Object Client-Server Framework)<p>** @author Dr Robert Lagani&egrave;re* @author Dr Timothy C. Lethbridge* @author Fran&ccedil;ois B&eacute;langer* @author Paul Holden* @version February 2001 (2.12)* @see ConnectionToClient*/public abstract class AbstractServer implements Runnable {  // INSTANCE VARIABLES *********************************************  /**   * The osf.server socket: listens for clients who want to connect.   */  private ServerSocket serverSocket = null;  /**   * The connection listener thread.   */  private Thread connectionListener;  /**   * The port number   */  private int port;  /**   * The osf.server timeout while for accepting connections.   * After timing out, the osf.server will check to see if a command to   * stop the osf.server has been issued; it not it will resume accepting   * connections.   * Set to half a second by default.   */  private int timeout = 500;  /**   * The maximum queue length; i.e. the maximum number of clients that   * can be waiting to connect.   * Set to 10 by default.   */  private int backlog = 10;  /**   * The thread group associated with ocf.client threads. Each member of the   * thread group is a <code> osf.server.ConnectionToClient </code>.   */  private ThreadGroup clientThreadGroup;  /**   * Indicates if the listening thread is ready to stop.  Set to   * false by default.   */  private boolean readyToStop = false;// CONSTRUCTOR ******************************************************  /**   * Constructs a new osf.server.   *   * @param port the port number on which to listen.   */  public AbstractServer(int port) {    this.port = port;    this.clientThreadGroup =            new ThreadGroup("osf.server.ConnectionToClient threads") {              // All uncaught exceptions in connection threads will              // be sent to the clientException callback method.              public void uncaughtException(                      Thread thread, Throwable exception) {                clientException((ConnectionToClient) thread, exception);              }            };  }// INSTANCE METHODS *************************************************  /**   * Begins the thread that waits for new clients.   * If the osf.server is already in listening mode, this   * call has no effect.   *   * @throws IOException if an I/O error occurs   *                     when creating the osf.server socket.   */  final public void listen() throws IOException {    if (!isListening()) {      if (serverSocket == null) {        serverSocket = new ServerSocket(getPort(), backlog);      }      serverSocket.setSoTimeout(timeout);      readyToStop = false;      connectionListener = new Thread(this);      connectionListener.start();    }  }  /**   * Causes the osf.server to stop accepting new connections.   */  final public void stopListening() {    readyToStop = true;  }  /**   * Closes the osf.server socket and the connections with all clients.   * Any exception thrown while closing a ocf.client is ignored.   * If one wishes to catch these exceptions, then clients   * should be individually closed before calling this method.   * The method also stops listening if this thread is running.   * If the osf.server is already closed, this   * call has no effect.   *   * @throws IOException if an I/O error occurs while   *                     closing the osf.server socket.   */  final synchronized public void close() throws IOException {    if (serverSocket == null)      return;    stopListening();    try {      serverSocket.close();    } finally {      // Close the ocf.client sockets of the already connected clients      Thread[] clientThreadList = getClientConnections();      for (Thread thread : clientThreadList) {        try {          ((ConnectionToClient) thread).close();        }        // Ignore all exceptions when closing clients.        catch (Exception ex) {          ex.printStackTrace();        }      }      serverSocket = null;      serverClosed();    }  }  /**   * Sends a message to every ocf.client connected to the osf.server.   * This is merely a utility; a subclass may want to do some checks   * before actually sending messages to all clients.  This method   * can be overriden, but if so it should still perform the general   * function of sending to all clients, perhaps after some kind   * of filtering is done. Any exception thrown while   * sending the message to a particular ocf.client is ignored.   *   * @param msg Object The message to be sent   */  public void sendToAllClients(Object msg, ConnectionToClient sender) {    ConnectionToClient[] clientList = (ConnectionToClient[]) getClientConnections();    for (ConnectionToClient client : clientList) {      try {        if (!client.equals(sender)) client.sendToClient(msg);      } catch (Exception ex) {        ex.printStackTrace();      }    }  }// ACCESSING METHODS ------------------------------------------------  /**   * Returns true if the osf.server is ready to accept new clients.   *   * @return true if the osf.server is listening.   */  final public boolean isListening() {    return (connectionListener != null);  }  /**   * Returns an array containing the existing   * ocf.client connections. This can be used by   * concrete subclasses to implement messages that do something with   * each connection (e.g. kill it, send a message to it etc.).   * Remember that after this array is obtained, some clients   * in this migth disconnect. New clients can also connect,   * these later will not appear in the array.   *   * @return an array of <code>Thread</code> containing   * <code>osf.server.ConnectionToClient</code> instances.   */  synchronized final public Thread[] getClientConnections() {    Thread[] clientThreadList = new            Thread[clientThreadGroup.activeCount()];    clientThreadGroup.enumerate(clientThreadList);    return clientThreadList;  }  /**   * Counts the number of clients currently connected.   *   * @return the number of clients currently connected.   */  final public int getNumberOfClients() {    return clientThreadGroup.activeCount();  }  /**   * Returns the port number.   *   * @return the port number.   */  final public int getPort() {    return port;  }  /**   * Sets the port number for the next connection.   * The osf.server must be closed and restarted for the port   * change to be in effect.   *   * @param port the port number.   */  final public void setPort(int port) {    this.port = port;  }  /**   * Sets the timeout time when accepting connections.   * The default is half a second. This means that stopping the   * osf.server may take up to timeout duration to actually stop.   * The osf.server must be stopped and restarted for the timeout   * change to be effective.   *   * @param timeout the timeout time in ms.   */  final public void setTimeout(int timeout) {    this.timeout = timeout;  }  /**   * Sets the maximum number of waiting connections accepted by the   * operating system. The default is 20.   * The osf.server must be closed and restarted for the backlog   * change to be in effect.   *   * @param backlog the maximum number of connections.   */  final public void setBacklog(int backlog) {    this.backlog = backlog;  }// RUN METHOD -------------------------------------------------------  /**   * Runs the listening thread that allows clients to connect.   * Not to be called.   */  final public void run() {    // call the hook method to notify that the osf.server is starting    try {      serverStarted();      // Repeatedly waits for a new ocf.client connection, accepts it, and      // starts a new thread to handle data exchange.      while (!readyToStop) {        try {          // Wait here for new connection attempts, or a timeout          Socket clientSocket = serverSocket.accept();          // When a ocf.client is accepted, create a thread to handle          // the data exchange, then add it to thread group          synchronized (this) {            ConnectionToClient c = new ConnectionToClient(                    this.clientThreadGroup, clientSocket, this);          }        } catch (InterruptedIOException exception) {          // This will be thrown when a timeout occurs.          // The osf.server will continue to listen if not ready to stop.        }      }      // call the hook method to notify that the osf.server has stopped      serverStopped();    } catch (IOException exception) {      if (!readyToStop) {        // Closing the socket must have thrown a SocketException        listeningException(exception);      } else {        serverStopped();      }    } finally {      readyToStop = true;      connectionListener = null;    }  }// METHODS DESIGNED TO BE OVERRIDDEN BY CONCRETE SUBCLASSES ---------  /**   * Hook method called each time a new ocf.client connection is   * accepted. The default implementation does nothing.   *   * @param client the connection connected to the ocf.client.   */  protected void clientConnected(ConnectionToClient client) {  }  /**   * Hook method called each time a ocf.client disconnects.   * The default implementation does nothing. The method   * may be overridden by subclasses but should remains synchronized.   *   * @param client the connection with the ocf.client.   */  synchronized protected void clientDisconnected(          ConnectionToClient client) {  }  /**   * Hook method called each time an exception is thrown in a   * osf.server.ConnectionToClient thread.   * The method may be overridden by subclasses but should remains   * synchronized.   *   * @param client    the ocf.client that raised the exception.   * @param exception the exception thrown.   */  synchronized protected void clientException(          ConnectionToClient client, Throwable exception) {  }  /**   * Hook method called when the osf.server stops accepting   * connections because an exception has been raised.   * The default implementation does nothing.   * This method may be overriden by subclasses.   *   * @param exception the exception raised.   */  protected void listeningException(Throwable exception) {  }  /**   * Hook method called when the osf.server starts listening for   * connections.  The default implementation does nothing.   * The method may be overridden by subclasses.   */  protected void serverStarted() throws UnknownHostException {  }  /**   * Hook method called when the osf.server stops accepting   * connections.  The default implementation   * does nothing. This method may be overriden by subclasses.   */  protected void serverStopped() {  }  /**   * Hook method called when the osf.server is clased.   * The default implementation does nothing. This method may be   * overriden by subclasses. When the osf.server is closed while still   * listening, serverStopped() will also be called.   */  protected void serverClosed() {  }  /**   * Handles a command sent from one ocf.client to the osf.server.   * This MUST be implemented by subclasses, who should respond to   * messages.   * This method is called by a synchronized method so it is also   * implcitly synchronized.   *   * @param msg    the message sent.   * @param client the connection connected to the ocf.client that   *               sent the message.   */  protected abstract void handleMessageFromClient(          Object msg, ConnectionToClient client);// METHODS TO BE USED FROM WITHIN THE FRAMEWORK ONLY ----------------  /**   * Receives a command sent from the ocf.client to the osf.server.   * Called by the run method of <code>osf.server.ConnectionToClient</code>   * instances that are watching for messages coming from the osf.server   * This method is synchronized to ensure that whatever effects it has   * do not conflict with work being done by other threads. The method   * simply calls the <code>handleMessageFromClient</code> slot method.   *   * @param msg    the message sent.   * @param client the connection connected to the ocf.client that   *               sent the message.   */  final synchronized void receiveMessageFromClient(          Object msg, ConnectionToClient client) {    this.handleMessageFromClient(msg, client);  }}